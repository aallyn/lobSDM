library(RCMEMS)
library(tidyverse)
library(stringr)
library(sf)
library(raster)
library(lubridate)
library(gmRi)
# devtools::install_github("rstudio/reticulate")
library(reticulate)
library(ncdf4)

source("Code/enhance_r_funcs.R")

#####
## Preliminary set up
#####
glorys_path<- cs_path(box_group = "RES_Data", subfolder = "GLORYs/NE_Shelf_TempSal/")

# Some quick exploration to get familiar with things
list.files(glorys_path)

t_nc <- nc_open(list.files(glorys_path, full.names = TRUE)[[1]])
print(t_nc)
t_nc$dim

#####
## Sourcing Adam's python script for extracting bottom temperature
#####
# Adam has a nice script for extracting bottom temperature here (https://github.com/adamkemberling/glorys_northeast/blob/main/py/bottom_layer_extraction.py). It was a bit nutty to try to get this all working, I am wayyy out of practice with this stuff and Adam is leap years ahead of me. For what it's worth, here's what I had to do (after making sure python, jupetyr and such were all set)

# Open terminal and type `python -m venv myenv`
# pip install ipykernel
# python -m ipykernel install --user --name=aallyn --display-name "Python (myenv)" 

# Next, I opened the .ipynb and in the top right I had to basically get the python thing to be working with the virtual environment I just set up.

# After doing that, I was then able to run .ipynb cells and debug as needed (for example, I had to run `pip install xarray` and do the same call for any other...modules? missing?)
glorys_new_path<- cs_path(box_group = "RES_Data", subfolder = "GLORYs/NE_Shelf_MonthlyTemps/")
t<- raster(paste0(glorys_new_path, "BT.nc"))
t
plot(t[[1]])

t2<- raster(paste0(glorys_new_path, "SST.nc"))
t2
plot(t2[[1]])

# Looks good! We eventually ran into issues with the extent and unfortunately I couldn't get Adam's download to work well without having to enter my credentials every single time. I eventually did a work around, but also tried this "old way", which didn't work and consistently timed out on me. Keeping just in case it is helpful!
latitude_min = 35.2
latitude_max = 48
longitude_min = -75.8
longitude_max = -56.2
date_min = '1993-01-01'
date_max = '1993-12-31'
output_dir = "/Users/aallyn/Library/CloudStorage/Box-Box/RES_Data/GLORYs/NW_Atl_MonthlyTemps/"

GLORYS_script <- 'python3 /usr/local/lib/python3.9/site-packages/motuclient.py --motu http://my.cmems-du.eu/motu-web/Motu --service-id GLOBAL_MULTIYEAR_PHY_001_030 --product-id cmems_mod_glo_phy_my_0.083deg_P1M-m --longitude-min -180 --longitude-max 179.9166717529297 --latitude-min -80 --latitude-max 90 --date-min "2018-12-25 12:00:00" --date-max "2018-12-25 12:00:00" --depth-min 0 --depth-max 1500 --variable "thetao" --out-dir data --out-name test.nc --user aallyn --pwd Maine198513 --config-file $HOME/motuclient_files/config.ini --no-ssl'
GLORYS_script<- 'python3 /usr/local/lib/python3.9/site-packages/motuclient.py --motu http://my.cmems-du.eu/motu-web/Motu --service-id GLOBAL_MULTIYEAR_PHY_001_030 --product-id global-reanalysis-phy-001-030-daily --longitude-min 0 --longitude-max 10 --latitude-min 0 --latitude-max 10 --date-min "2019-01-01 12:00:00" --date-max "2019-01-02 12:00:00" --depth-min 0.493 --depth-max 0.494 --variable thetao --out-dir ./ --out-name historical_test.nc --user aallyn --pwd Maine198513'

cfg <- parse.CMEMS.script(GLORYS_script, parse.user = T)

cfg_update <- RCMEMS::update(cfg,
      longitude.min = as.character(longitude_min),
      longitude.max = as.character(longitude_max),
      latitude.min = as.character(latitude_min),
      latitude.max = as.character(latitude_max),
      date.min = "1993-01-01",
      date.max = "1993-12-31",
      out.dir = output_dir,
      out.name = "test.nc"
  )

CMEMS.download(cfg_update)



# Download function -- this was modified slightly from https://theoceancode.netlify.app/post/dl_env_data_r/
download_GLORYS <- function(date_choice, extent_bbox = extent_gom, out_dir_use = "$HOME/Box/RES_Data/GLORYs/GulfofMaine_Monthly/"){
  
  if(FALSE){
    date_choice<- date_range$year_mon[1]
  }
  
  # The GLORYS script
    # This is a dummy script first generated by using the UI on the CMEMS website
    # No need to change anything here except for the --user and --pwd at the end
    # Please place your CMEMS username and password in those fields
  GLORYS_script <- 'python3 /usr/local/lib/python3.9/site-packages/motuclient.py --motu http://my.cmems-du.eu/motu-web/Motu --service-id GLOBAL_REANALYSIS_PHY_001_031 --product-id monthly --longitude-min -180 --longitude-max 179.9166717529297 --latitude-min -80 --latitude-max 90 --date-min "2018-12-25 12:00:00" --date-max "2018-12-25 12:00:00" --depth-min 0.493 --depth-max 0.4942 --variable thetao --variable bottomT --variable so --variable zos --variable uo --variable vo --variable mlotst --variable siconc --variable sithick --variable usi --variable vsi --out-dir data --out-name test.nc --user aallyn --pwd Maine198513 --config-file $HOME/motuclient_files/config.ini'
  
  cfg_update <- RCMEMS::update(cfg, variable = "thetao --variable bottomT --variable so --variable zos --variable uo --variable vo --variable mlotst --variable siconc --variable sithick --variable usi --variable vsi",
                               longitude.min = as.character(extent_bbox$xmin),
                               longitude.max = as.character(extent_bbox$xmax),
                               latitude.min = as.character(extent_bbox$ymin),
                               latitude.max = as.character(extent_bbox$ymax),
                               date.min = as.character(date_start),
                               date.max = as.character(date_end),
                               out.dir = out_dir_use,
                               out.name = file_name)
  # Prep the necessary URL pieces
  date_start <- parse_date(date_choice, format = "%Y-%m")
  # A clever way of finding the end date of any month!
    # I found this on stackoverflow somewhere...
  date_end <- date_start %m+% months(1) - 1
  
  # Set the file name
  file_name <- paste0("GLORYS_", date_choice, ".nc")
  print(file_name)
  
  # Take the chunk of code above and turn it into something useful
  cfg <- parse.CMEMS.script(GLORYS_script, parse.user = T)
  
  # This is where one should make any required changes to the subsetting of the data
  # This is now the magic of the RCMEMS package, which allows us to interface with the Python code as though it were R
  cfg_update <- RCMEMS::update(cfg, variable = "thetao --variable bottomT --variable so --variable zos --variable uo --variable vo --variable mlotst --variable siconc --variable sithick --variable usi --variable vsi",
                               longitude.min = as.character(extent_bbox$xmin),
                               longitude.max = as.character(extent_bbox$xmax),
                               latitude.min = as.character(extent_bbox$ymin),
                               latitude.max = as.character(extent_bbox$ymax),
                               date.min = as.character(date_start),
                               date.max = as.character(date_end),
                               out.dir = out_dir_use,
                               out.name = file_name)
  
  # Download and save the file if needed
  if(file.exists(paste0(out_dir_use, file_name))){
    return()
  } else{
    CMEMS.download(cfg_update)
  }
  Sys.sleep(2) # Give the server a quick breather
}
